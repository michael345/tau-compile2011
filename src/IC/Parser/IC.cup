package IC.Parser;

import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import IC.*;
import IC.AST.*;
import IC.Parser.*;

parser code {:


	/**
	 * Causes the parser to print every token it reads. useful for debugging
	 */
	public boolean printTokens;
	
	private Lexer lexer;
	private int ecode;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public void log(String msg) {
			String curcut = msg;
			System.out.println(getLine() + " : " + msg);
	}
	public int getLine() {
		return lexer.getLine();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		SyntaxError e = new SyntaxError(tok);
		e.printErrorMsg();
		//System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + Utils.tokenIDToString(tok.getId()));
	                                   //Line 7:         Syntax error; unexpected        ELSE
	}
	
:};
// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + Utils.tokenIDToString(t.getId()));
	return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program program;
non terminal ICClass class;
non terminal List<ICClass> class_list;
non terminal Field	field;
non terminal List<Field> fields;
non terminal List<Field> fieldsinrow;
non terminal Method	method;
non terminal Type	type;
non terminal Formal formal;
non terminal List<Formal> formals;
non terminal Statement statement;
non terminal StatementsBlock stmt_list;
non terminal If ifStatement;
non terminal Statement elseStatement;
non terminal Expression expr;
non terminal List<Expression> exprlist, actualParams;     
non terminal ClassContents classcontents;
non terminal Location location;
non terminal Call call;
non terminal StaticCall staticCall;
non terminal VirtualCall virtualCall;


terminal String INTEGER;
terminal String  QUOTE;
terminal String ID, CLASS_ID;
terminal FALSE, TRUE;
terminal LENGTH, NEQUAL, EQUAL, RP, SEMI, DOT, LP, PLUS, MINUS, MULTIPLY, DIVIDE, GT, GTE, LT, LTE, LB, LCBR, RCBR, RB, LNEG, LAND, LOR, MOD, COMMA,
		 IF, ASSIGN, BREAK, CLASS, CONTINUE, EXTENDS, ELSE, NEW, RETURN, THIS, VOID, WHILE, STATIC;
terminal INT, STRING, BOOLEAN, UMINUS;
terminal NULL;

//////////////////////////
// Precedence declarations
precedence left ELSE;
precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GTE, GT, LT, LTE;
precedence left MINUS, PLUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right UMINUS, LNEG; 
precedence left DOT, LP, RP, LB, RB;


//////////////
// The grammar

program ::= class_list:cl {:
	parser.log("program ::= class_list");
	RESULT = new Program(cl); :}
;

class_list ::= class:c {:
		parser.log("class_list ::= class");
      	RESULT = new ArrayList<ICClass>(); RESULT.add(c);
      :}
      	| class_list:cl class:c {: 
      		parser.log("class_list ::= class_list class");
      		cl.add(c); RESULT = cl; :}
;

class ::= CLASS CLASS_ID:name EXTENDS CLASS_ID:superclassico LCBR classcontents:cc RCBR {: 
	parser.log("class::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR classcontents RCBR");
	RESULT = new ICClass(nameleft,name,superclassico, cc.getFields(), cc.getMethods());	
	:} | 
	CLASS CLASS_ID:name LCBR classcontents:cc RCBR {: 
		parser.log("class::= CLASS CLASS_ID  CLASS_ID LCBR classcontents RCBR");
		RESULT = new ICClass(nameleft,name, cc.getFields(), cc.getMethods());	
	:} | 
	CLASS CLASS_ID:name EXTENDS CLASS_ID:superclassico LCBR RCBR {: 
		parser.log("class::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR RCBR");
	RESULT = new ICClass(nameleft,name,superclassico, new ArrayList<Field>(), new ArrayList<Method>());
	:} | 
	CLASS CLASS_ID:name LCBR RCBR {: 
		parser.log("class::= CLASS CLASS_ID  CLASS_ID LCBR RCBR");
		RESULT = new ICClass(nameleft,name, new ArrayList<Field>(), new ArrayList<Method>());
	:}
;
	

classcontents ::= 
	fields:f {:
		parser.log("classcontents ::= fields");
		ClassContents cc = new ClassContents(parser.getLine());
		List<Field> fields = cc.getFields();
		fields.addAll(f);
		cc.setFields(fields);
		RESULT = cc;
	 :} |
	 method:m {:
	 	parser.log("classcontents ::= method");
		ClassContents cc = new ClassContents(parser.getLine());
		List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :} | 
	 classcontents:cc fields:f {:
	 	parser.log("classcontents ::= classcontents fields");
	 	List<Field> fields = cc.getFields();
	 	fields.addAll(f);
	 	cc.setFields(fields);
		RESULT = cc;
	 :} | 
	 classcontents:cc method:m {:
	 	parser.log("classcontents ::= classcontents method");
	 	List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :}
;


fields ::= fieldsinrow:row SEMI {:
	parser.log("fields ::= fieldsinrow SEMI");
	RESULT = row; :}
; 

fieldsinrow ::= 
		field:f {:
			parser.log("fieldsinrow ::= field");
			ArrayList<Field> list = new ArrayList<Field>();
			list.add(f);
			RESULT = list; :} |
		fieldsinrow:row COMMA ID:id {:
			parser.log("fieldsinrow ::= fieldsinrow COMMA ID");
			Field field = new Field(row.get(0).getType(), id);
			row.add(field);
			RESULT = row;
		:}
;
		
field ::=
	      type:t ID:id {:
	      	parser.log("field ::= type ID");
   		  	RESULT = new Field(t,id); :}
;
			 	 	 
method ::=  STATIC type:t ID:f LP formals:formals RP stmt_list:st {:
				parser.log("method ::= STATIC type ID LP formals RP stmt_list");
				RESULT = new StaticMethod(t,f,formals, st.getStatements()); :} |
			type:t ID:f LP formals:formals RP stmt_list:st  {:
				parser.log("method ::= type ID LP formals RP stmt_list");
				RESULT = new VirtualMethod(t,f,formals, st.getStatements()); :} |
			STATIC type:t ID:f LP RP stmt_list:st  {:
				parser.log("method ::= STATIC type ID LP RP stmt_list");
				RESULT = new StaticMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			type:t ID:f LP RP stmt_list:st  {:
				parser.log("method ::= type ID LP RP stmt_list");
				RESULT = new VirtualMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			STATIC VOID ID:f LP formals:formals RP stmt_list:st  {:
				parser.log("method ::= STATIC VOID ID LP formals RP stmt_list");
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			VOID ID:f LP formals:formals RP stmt_list:st  {:
				parser.log("method ::= VOID ID LP formals RP stmt_list");
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			STATIC VOID ID:f LP RP stmt_list:st  {:
				parser.log("method ::= STATIC VOID ID LP RP stmt_list");
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :} |
			VOID ID:f LP RP stmt_list:st  {:
				parser.log("method ::= VOID ID LP RP stmt_list");
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :}
;

formal ::= type:t ID:id {:
	parser.log("formal ::= type ID");
	RESULT = new Formal(t,id); :}
;

formals ::= formal:fo {:
				parser.log("formals ::= formal");
				ArrayList<Formal> flist = new ArrayList<Formal>();
				flist.add(fo); RESULT = flist; :} |
			formals:flist COMMA formal:fo {:
				parser.log("formals ::= flist COMMA formal");
				flist.add(fo); RESULT = flist; :}
;
				 
		
	
type ::= INT {:
			parser.log("type ::= INT");
			RESULT = new PrimitiveType(parser.getLine(), DataTypes.INT);:} | 
	    STRING {:
	    	parser.log("type ::= STRING");
	    	RESULT = new PrimitiveType(parser.getLine(), DataTypes.STRING);:} | 
	    BOOLEAN{:
	    	parser.log("type ::= BOOLEAN");	
	    	RESULT = new PrimitiveType(parser.getLine(), DataTypes.BOOLEAN);:} | 
	    CLASS_ID:c {:
	    	parser.log("type ::= CLASS_ID");
	    	RESULT = new UserType(parser.getLine(), c); :} |
		type:t LB RB {:
			parser.log("type ::= type LB RB");
			t.incrementDimension();
			RESULT = t;
		:}
;

expr ::=	
			expr:e1 PLUS expr:e2 {: 
				parser.log("expr ::= expr PLUS expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.PLUS,e2); :} |
			expr:e1 MINUS expr:e2 {:
				parser.log("expr ::= expr MINUS expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.MINUS,e2); :} |
			expr:e1 MULTIPLY expr:e2 {: 
				parser.log("expr ::= expr MULTIPLY expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.MULTIPLY,e2); :} |
			expr:e1 DIVIDE expr:e2 {:
				parser.log("expr ::= expr DIVIDE expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.DIVIDE,e2); :} |
			expr:e1 MOD expr:e2 {:
				parser.log("expr ::= expr MOD expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.MOD,e2); :} |
			expr:e1 EQUAL expr:e2 {:
				parser.log("expr ::= expr EQUAL expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.EQUAL,e2); :} |
			expr:e1 NEQUAL expr:e2 {:
				parser.log("expr ::= expr NEQUAL expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.NEQUAL,e2); :} |
			expr:e1 GT expr:e2 {: 
				parser.log("expr ::= expr GT expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.GT,e2); :} |
			expr:e1 GTE expr:e2 {: 
				parser.log("expr ::= expr GTE expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.GTE,e2); :} |
			expr:e1 LT expr:e2 {:
				parser.log("expr ::= expr LT expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.LT,e2); :} |
			expr:e1 LTE expr:e2 {:
				parser.log("expr ::= expr LTE expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.LTE,e2); :} |
			expr:e1 LAND expr:e2 {: 
				parser.log("expr ::= expr LAND expr");
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LAND,e2); :} |
			expr:e1 LOR expr:e2 {: 
				parser.log("expr ::= expr LOR expr");
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LOR,e2); :} |
			LNEG expr:e1 {: 
				parser.log("expr ::= LNEG expr");
				RESULT = new LogicalUnaryOp(UnaryOps.LNEG,e1); :} |
			MINUS expr:e1  {:
				parser.log("expr ::= MINUS expr");
				RESULT = new MathUnaryOp(UnaryOps.UMINUS,e1); :} %prec UMINUS |
			ID:f LP exprlist:args RP {:
				parser.log("expr ::= ID LP exprlist RP");
				RESULT = new VirtualCall(parser.getLine(),f,args); :} |
			expr:arr DOT LENGTH {:
				parser.log("expr ::= expr DOT LENGTH");
				RESULT = new Length(arr); :} |
			QUOTE:str {:
				parser.log("expr ::= QUOTE");
				RESULT = new Literal(parser.getLine(),LiteralTypes.STRING,str); :} |
			LP expr:e1 RP {:
				 parser.log("expr ::= LP expr RP");
				 RESULT = new ExpressionBlock(e1); :} |
			NEW:id CLASS_ID:name LP RP  {:
				parser.log("expr ::= NEW CLASS_ID LP RP ");
				RESULT = new NewClass(parser.getLine(),name); :} |
			NEW:id type:name LB expr:size RB {:
				parser.log("expr ::= NEW type LB expr RB");
				RESULT = new NewArray(name,size); :} |
			location:e {:
				parser.log("expr ::= location");
				RESULT = e;:} | 
			call:e {:
				parser.log("expr ::= call");
				RESULT = e;:} |
			THIS {:
				parser.log("expr ::= THIS");
				RESULT = new This(parser.getLine());:}  |
			INTEGER:x {:
				parser.log("expr ::= INTEGER");
				RESULT = new Literal(parser.getLine(), LiteralTypes.INTEGER, x);:} |
			TRUE:x {:
				parser.log("expr ::= TRUE");
				RESULT = new Literal(parser.getLine(),LiteralTypes.TRUE);:}  |
			FALSE:x {:
				parser.log("expr ::= FALSE");
				RESULT = new Literal(parser.getLine(),LiteralTypes.FALSE);:}  |
			NULL:x {:
				parser.log("expr ::= NULL");
				RESULT = new Literal(parser.getLine(),LiteralTypes.NULL);:} 
;

exprlist ::= expr:e {:
				parser.log("exprlist ::= expr");
				List<Expression> list = new ArrayList<Expression>();
				list.add(e);
				RESULT = list; :} | 
 			exprlist:list COMMA expr:e {:
 			 	parser.log("exprlist ::= exprlist COMMA expr");
 			 	list.add(e);
 			 	RESULT = list;:} 
;

stmt_list ::= statement:st {:
		parser.log("stmt_list ::= statement");
		List<Statement> temp = new ArrayList<Statement>(); temp.add(st); 
		RESULT = new StatementsBlock(parser.getLine(),temp);
	:} 	|
	stmt_list:s1 statement:s {:
		parser.log("stmt_list ::= stmt_list statement");
		List<Statement> temp = s1.getStatements();
		temp.add(s);
		RESULT = new StatementsBlock(parser.getLine(), temp); 
	:}
;

ifStatement ::= IF LP expr:e RP statement:s {:
					parser.log("ifStatement ::= IF LP expr RP statement");
					RESULT = new If(e,s);
				:}
;
elseStatement ::= ELSE statement:es {:
					parser.log("elseStatement ::= ELSE statement:");
					RESULT = es;
				:}
;

statement ::= 	ifStatement:ifs {:
					parser.log("statement ::= ifStatement");
					RESULT = ifs;:} |
				ifStatement:ifs elseStatement:est {: 
					parser.log("statement ::= ifStatement elseStatement");
					Statement then = ifs.getOperation();
					Expression cond = ifs.getCondition();
					RESULT = new If(cond,then,est);:} |
				WHILE LP expr:e RP statement:s {: 
					parser.log("statement ::= WHILE LP expr RP statement");
					RESULT = new While(e,s);:} |
				BREAK:b SEMI {:
					parser.log("statement ::= BREAK SEMI");
					RESULT = new Break(parser.getLine()); :} |
				CONTINUE SEMI {:
					parser.log("statement ::= CONTINUE SEMI");
					RESULT = new Continue(parser.getLine()); :} |
				RETURN expr:e SEMI {:
					parser.log("statement ::= RETURN expr SEMI");
					RESULT = new Return(parser.getLine(),e); :} |
				RETURN SEMI {:
					parser.log("statement ::= RETURN SEMI");
					RESULT = new Return(parser.getLine()); :} |
				ID:f LP exprlist:args RP SEMI {: 
					parser.log("statement ::= ID LP exprlist RP SEMI");
					RESULT = new CallStatement(new VirtualCall(parser.getLine(),f,args)); :} |
				type:t ID:id ASSIGN expr:e SEMI {: 
					parser.log("statement ::= type ID ASSIGN expr SEMI");
					Location loc = new VariableLocation(parser.getLine(),id);
					RESULT = new Assignment(loc,e); :}  |
				type:t ID:id SEMI {:
					parser.log("statement ::= type ID SEMI");
					RESULT = new LocalVariable(t,id); :} |
				call:c SEMI {:
					parser.log("statement ::= call SEMI");
					RESULT = new CallStatement(c);
				:} |
				location:loc ASSIGN expr:e SEMI {:
					parser.log("statement ::= location ASSIGN expr SEMI");
					RESULT = new Assignment(loc,e);
				:}  |
				LCBR stmt_list:st RCBR {:
					parser.log("statement ::= LCBR stmt_list RCBR");
					RESULT = st;
				:}
;

location ::=	ID:id {:
					parser.log("location ::= ID");
					RESULT = new VariableLocation(parser.getLine(), id);:} |
			  	expr:e DOT ID:id {:
			  		parser.log("location ::= expr DOT ID");
			  		RESULT = new VariableLocation(parser.getLine(), e, id); :} |
			  	expr:arr LB expr:index RB {:
			  		parser.log("location ::= expr LB expr RB");
			  		RESULT = new ArrayLocation(arr,index); :}
;

call ::= 	staticCall:c {: 
				parser.log("call ::= staticCall");
				RESULT = c;
			:} |
			virtualCall:c {: 
				parser.log("call ::= virtualCall");
				RESULT = c;
			:} ;

staticCall ::= CLASS_ID:c DOT ID:f LP exprlist:args RP {:
				parser.log("staticCall ::= CLASS_ID DOT ID LP exprlist RP");
				RESULT = new StaticCall(parser.getLine(),c, f,args);  :} |
			CLASS_ID:c DOT ID:f LP RP {:
				parser.log("staticCall ::= CLASS_ID DOT ID LP RP");
				RESULT = new StaticCall(parser.getLine(),c, f,new ArrayList<Expression>());  :}
				
;

virtualCall ::= expr:e DOT ID:f LP exprlist:args RP {:
					parser.log("virtualCall ::= expr DOT ID LP exprlist RP");
					RESULT = new VirtualCall(parser.getLine(),e,f,args);:} |
				ID:name LP actualParams:args RP {:
					parser.log("virtualCall ::= ID LP actualParams:args RP");
					RESULT = new VirtualCall(parser.getLine(),name,args);:} |
				expr:e DOT ID:f LP RP {:
					parser.log("virtualCall ::= expr DOT ID LP RP");
					RESULT = new VirtualCall(parser.getLine(),e,f,new ArrayList<Expression>());:} |
				ID:name LP RP {:
					parser.log("virtualCall ::= ID LP RP");
					RESULT = new VirtualCall(parser.getLine(),name,new ArrayList<Expression>());:}
;
			  	